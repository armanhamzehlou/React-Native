{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport * as FileSystem from 'expo-file-system';\nvar FaceRecognitionService = function () {\n  function FaceRecognitionService() {\n    _classCallCheck(this, FaceRecognitionService);\n    this.isInitialized = false;\n    this.faceDatabase = new Map();\n    this.faceDbPath = Platform.OS === 'web' ? '/FaceDB' : `${FileSystem.documentDirectory}FaceDB/`;\n  }\n  _createClass(FaceRecognitionService, [{\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator(function* () {\n        try {\n          console.log('Initializing Face Recognition Service for', Platform.OS);\n          if (Platform.OS === 'web') {\n            console.log('Web environment detected - running in demo mode');\n            console.log('TensorFlow.js and face-api.js would be loaded here in production');\n            this.isInitialized = true;\n            console.log('Face Recognition Service initialized');\n            return;\n          }\n          if (Platform.OS === 'android' || Platform.OS === 'ios') {\n            if (!FileSystem) {\n              throw new Error('FileSystem not available');\n            }\n            console.log('Creating FaceDB directory at:', this.faceDbPath);\n            var dirInfo = yield FileSystem.getInfoAsync(this.faceDbPath);\n            console.log('Directory check result:', dirInfo);\n            if (!dirInfo.exists) {\n              yield FileSystem.makeDirectoryAsync(this.faceDbPath, {\n                intermediates: true\n              });\n              console.log('Created FaceDB directory:', this.faceDbPath);\n              var verifyInfo = yield FileSystem.getInfoAsync(this.faceDbPath);\n              if (!verifyInfo.exists) {\n                throw new Error('Failed to create FaceDB directory');\n              }\n              console.log('Verified FaceDB directory exists');\n            } else {\n              console.log('FaceDB directory already exists');\n            }\n            this.isInitialized = true;\n            console.log('‚úÖ Face Recognition Service initialized successfully for', Platform.OS);\n            return;\n          } else {\n            throw new Error(`Platform ${Platform.OS} not supported`);\n          }\n        } catch (error) {\n          console.error('Failed to initialize Face Recognition Service:', error);\n          console.error('Error details:', error.message);\n          this.isInitialized = false;\n          throw error;\n        }\n      });\n      function initialize() {\n        return _initialize.apply(this, arguments);\n      }\n      return initialize;\n    }()\n  }, {\n    key: \"getFaceDbImages\",\n    value: function () {\n      var _getFaceDbImages = _asyncToGenerator(function* () {\n        var _this = this;\n        try {\n          if (Platform.OS === 'web') {\n            console.log('Web environment - no real face database access available');\n            return [];\n          }\n          console.log('Checking FaceDB directory:', this.faceDbPath);\n          var dirInfo = yield FileSystem.getInfoAsync(this.faceDbPath);\n          if (!dirInfo.exists) {\n            console.log('FaceDB directory does not exist, creating it...');\n            yield FileSystem.makeDirectoryAsync(this.faceDbPath, {\n              intermediates: true\n            });\n            return [];\n          }\n          var files = yield FileSystem.readDirectoryAsync(this.faceDbPath);\n          console.log('Found files in FaceDB:', files);\n          var imageFiles = files.filter(function (file) {\n            return /\\.(jpg|jpeg|png|bmp)$/i.test(file);\n          });\n          console.log('Image files:', imageFiles);\n          var images = yield Promise.all(imageFiles.map(function () {\n            var _ref = _asyncToGenerator(function* (filename) {\n              var filePath = `${_this.faceDbPath}${filename}`;\n              try {\n                var base64 = yield FileSystem.readAsStringAsync(filePath, {\n                  encoding: FileSystem.EncodingType.Base64\n                });\n                var extension = filename.toLowerCase().split('.').pop();\n                var mimeType = 'image/jpeg';\n                if (extension === 'png') mimeType = 'image/png';else if (extension === 'bmp') mimeType = 'image/bmp';\n                var uri = `data:${mimeType};base64,${base64}`;\n                return {\n                  filename: filename,\n                  uri: uri,\n                  filePath: filePath\n                };\n              } catch (error) {\n                console.error(`Failed to read image ${filename}:`, error);\n                return {\n                  filename: filename,\n                  uri: null,\n                  filePath: filePath\n                };\n              }\n            });\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }()));\n          console.log(`Loaded ${images.length} images from FaceDB`);\n          return images.filter(function (img) {\n            return img.uri !== null;\n          });\n        } catch (error) {\n          console.error('Failed to get face database images:', error);\n          return [];\n        }\n      });\n      function getFaceDbImages() {\n        return _getFaceDbImages.apply(this, arguments);\n      }\n      return getFaceDbImages;\n    }()\n  }, {\n    key: \"addImageToFaceDb\",\n    value: function () {\n      var _addImageToFaceDb = _asyncToGenerator(function* (sourceUri, filename) {\n        console.log('üü° addImageToFaceDb called with:', {\n          sourceUri: sourceUri,\n          filename: filename,\n          platform: Platform.OS\n        });\n        try {\n          if (Platform.OS === 'web') {\n            console.log('Web demo: Would add image to face database');\n            return true;\n          }\n          if (!this.isInitialized) {\n            console.log('üü† Service not initialized in addImageToFaceDb, initializing...');\n            yield this.initialize();\n            if (!this.isInitialized) {\n              throw new Error('Face Recognition Service failed to initialize');\n            }\n          }\n          console.log('üü¢ Adding image from:', sourceUri, 'to FaceDB');\n          console.log('üü¢ FaceDB path:', this.faceDbPath);\n          var dirInfo = yield FileSystem.getInfoAsync(this.faceDbPath);\n          if (!dirInfo.exists) {\n            console.log('Creating FaceDB directory...');\n            yield FileSystem.makeDirectoryAsync(this.faceDbPath, {\n              intermediates: true\n            });\n            var verifyDir = yield FileSystem.getInfoAsync(this.faceDbPath);\n            if (!verifyDir.exists) {\n              throw new Error('Failed to create FaceDB directory');\n            }\n          }\n          if (!filename) {\n            var timestamp = Date.now();\n            var random = Math.floor(Math.random() * 1000);\n            filename = `face_${timestamp}_${random}.jpg`;\n          }\n          if (!filename.match(/\\.(jpg|jpeg|png|bmp)$/i)) {\n            filename += '.jpg';\n          }\n          var targetUri = `${this.faceDbPath}${filename}`;\n          console.log('Target URI:', targetUri);\n          console.log('üîç Checking source file:', sourceUri);\n          var sourceInfo = yield FileSystem.getInfoAsync(sourceUri);\n          console.log('üîç Source file info:', sourceInfo);\n          if (!sourceInfo.exists) {\n            throw new Error(`Source image not found: ${sourceUri}`);\n          }\n          console.log('‚úÖ Source image exists, size:', sourceInfo.size, 'bytes');\n          var targetExists = yield FileSystem.getInfoAsync(targetUri);\n          if (targetExists.exists) {\n            console.log('Target file already exists, generating new name...');\n            var _timestamp = Date.now();\n            var _random = Math.floor(Math.random() * 1000);\n            var baseName = filename.replace(/\\.[^/.]+$/, \"\");\n            var extension = filename.split('.').pop();\n            filename = `${baseName}_${_timestamp}_${_random}.${extension}`;\n            var newTargetUri = `${this.faceDbPath}${filename}`;\n            console.log('New target URI:', newTargetUri);\n            console.log('üìÅ Copying image with unique name from', sourceUri, 'to', newTargetUri);\n            yield FileSystem.copyAsync({\n              from: sourceUri,\n              to: newTargetUri\n            });\n            console.log('üìÅ Copy operation completed');\n            var copiedInfo = yield FileSystem.getInfoAsync(newTargetUri);\n            console.log('üìÅ Copied file info:', copiedInfo);\n            if (!copiedInfo.exists) {\n              throw new Error('Failed to copy image to face database');\n            }\n            console.log('‚úÖ Successfully copied image. Size:', copiedInfo.size, 'bytes');\n          } else {\n            console.log('üìÅ Copying image from', sourceUri, 'to', targetUri);\n            yield FileSystem.copyAsync({\n              from: sourceUri,\n              to: targetUri\n            });\n            console.log('üìÅ Copy operation completed');\n            var _copiedInfo = yield FileSystem.getInfoAsync(targetUri);\n            console.log('üìÅ Copied file info:', _copiedInfo);\n            if (!_copiedInfo.exists) {\n              throw new Error('Failed to copy image to face database');\n            }\n            console.log('‚úÖ Successfully copied image. Size:', _copiedInfo.size, 'bytes');\n          }\n          console.log(`üéâ Added image to face database: ${filename}`);\n          console.log('‚è≥ Waiting for file system sync...');\n          yield new Promise(function (resolve) {\n            return setTimeout(resolve, 500);\n          });\n          var finalTargetUri = targetExists.exists ? `${this.faceDbPath}${filename}` : targetUri;\n          var finalCheck = yield FileSystem.getInfoAsync(finalTargetUri);\n          console.log('üîç Final file check:', finalCheck);\n          if (!finalCheck.exists) {\n            throw new Error('Image was copied but disappeared after file system sync');\n          }\n          var allFiles = yield FileSystem.readDirectoryAsync(this.faceDbPath);\n          console.log('üìã All files in FaceDB after adding:', allFiles);\n          console.log('üîÑ Reloading face database...');\n          yield this.loadFaceDatabase();\n          return filename;\n        } catch (error) {\n          console.error('Failed to add image to face database:', error);\n          console.error('Error details:', error.message);\n          console.error('Stack trace:', error.stack);\n          throw error;\n        }\n      });\n      function addImageToFaceDb(_x2, _x3) {\n        return _addImageToFaceDb.apply(this, arguments);\n      }\n      return addImageToFaceDb;\n    }()\n  }, {\n    key: \"removeImageFromFaceDb\",\n    value: function () {\n      var _removeImageFromFaceDb = _asyncToGenerator(function* (filename) {\n        try {\n          if (Platform.OS === 'web') {\n            console.log('Web demo: Would remove image from face database');\n            return true;\n          }\n          var targetUri = `${this.faceDbPath}${filename}`;\n          var fileInfo = yield FileSystem.getInfoAsync(targetUri);\n          if (fileInfo.exists) {\n            yield FileSystem.deleteAsync(targetUri);\n            console.log(`Removed image from face database: ${filename}`);\n            this.faceDatabase.delete(filename);\n            return true;\n          }\n          return false;\n        } catch (error) {\n          console.error('Failed to remove image from face database:', error);\n          throw error;\n        }\n      });\n      function removeImageFromFaceDb(_x4) {\n        return _removeImageFromFaceDb.apply(this, arguments);\n      }\n      return removeImageFromFaceDb;\n    }()\n  }, {\n    key: \"loadFaceDatabase\",\n    value: function () {\n      var _loadFaceDatabase = _asyncToGenerator(function* () {\n        try {\n          if (Platform.OS === 'web') {\n            console.log('Running in web environment - no face database available');\n            this.faceDatabase.clear();\n            return 0;\n          }\n          var dirInfo = yield FileSystem.getInfoAsync(this.faceDbPath);\n          if (!dirInfo.exists) {\n            console.log('Creating FaceDB directory:', this.faceDbPath);\n            yield FileSystem.makeDirectoryAsync(this.faceDbPath, {\n              intermediates: true\n            });\n            return 0;\n          }\n          var files = yield FileSystem.readDirectoryAsync(this.faceDbPath);\n          var imageFiles = files.filter(function (file) {\n            return /\\.(jpg|jpeg|png|bmp)$/i.test(file);\n          });\n          console.log(`Found ${imageFiles.length} image files in FaceDB`);\n          this.faceDatabase.clear();\n          for (var file of imageFiles) {\n            try {\n              var filePath = `${this.faceDbPath}${file}`;\n              var descriptor = yield this.extractFaceDescriptor(filePath);\n              if (descriptor) {\n                this.faceDatabase.set(file, descriptor);\n                console.log(`Loaded face descriptor for: ${file}`);\n              }\n            } catch (error) {\n              console.error(`Failed to process ${file}:`, error);\n            }\n          }\n          console.log(`Face database loaded with ${this.faceDatabase.size} faces`);\n          return this.faceDatabase.size;\n        } catch (error) {\n          console.error('Failed to load face database:', error);\n          throw error;\n        }\n      });\n      function loadFaceDatabase() {\n        return _loadFaceDatabase.apply(this, arguments);\n      }\n      return loadFaceDatabase;\n    }()\n  }, {\n    key: \"extractFaceDescriptor\",\n    value: function () {\n      var _extractFaceDescriptor = _asyncToGenerator(function* (imagePath) {\n        try {\n          console.log(`Extracting face descriptor from: ${imagePath}`);\n          if (Platform.OS === 'web') {\n            var _descriptor = new Float32Array(128);\n            var hash = imagePath.length;\n            for (var i = 0; i < imagePath.length; i++) {\n              hash = hash * 31 + imagePath.charCodeAt(i) & 0x7fffffff;\n            }\n            for (var _i = 0; _i < 128; _i++) {\n              hash = hash * 1103515245 + 12345 & 0x7fffffff;\n              _descriptor[_i] = hash / 0x7fffffff * 2 - 1;\n            }\n            return _descriptor;\n          }\n          var fileInfo = yield FileSystem.getInfoAsync(imagePath);\n          if (!fileInfo.exists) {\n            console.error('Image file does not exist:', imagePath);\n            return null;\n          }\n          if (fileInfo.size < 1024) {\n            console.warn('Image file too small, may be low quality:', imagePath);\n            return null;\n          }\n          var imageData = yield FileSystem.readAsStringAsync(imagePath, {\n            encoding: FileSystem.EncodingType.Base64\n          });\n          var descriptor = new Float32Array(128);\n          var hash1 = fileInfo.size;\n          var hash2 = imagePath.length;\n          var hash3 = 0;\n          var chunkSize = Math.floor(imageData.length / 32);\n          for (var chunk = 0; chunk < 32; chunk++) {\n            var start = chunk * chunkSize;\n            var end = Math.min(start + chunkSize, imageData.length);\n            for (var _i2 = start; _i2 < end; _i2++) {\n              var char = imageData.charCodeAt(_i2);\n              hash1 = (hash1 << 5) - hash1 + char & 0xffffffff;\n              hash2 = hash2 * 31 + char & 0xffffffff;\n              hash3 = (hash3 ^ char) * 16777619 & 0xffffffff;\n            }\n          }\n          for (var _i3 = 0; _i3 < 128; _i3++) {\n            if (_i3 % 3 === 0) {\n              hash1 = hash1 * 1103515245 + 12345 & 0x7fffffff;\n              descriptor[_i3] = hash1 / 0x7fffffff * 2 - 1;\n            } else if (_i3 % 3 === 1) {\n              hash2 = hash2 * 1664525 + 1013904223 & 0x7fffffff;\n              descriptor[_i3] = hash2 / 0x7fffffff * 2 - 1;\n            } else {\n              hash3 = hash3 * 134775813 + 1 & 0x7fffffff;\n              descriptor[_i3] = hash3 / 0x7fffffff * 2 - 1;\n            }\n          }\n          var magnitude = 0;\n          for (var _i4 = 0; _i4 < 128; _i4++) {\n            magnitude += descriptor[_i4] * descriptor[_i4];\n          }\n          magnitude = Math.sqrt(magnitude);\n          if (magnitude > 0) {\n            for (var _i5 = 0; _i5 < 128; _i5++) {\n              descriptor[_i5] /= magnitude;\n            }\n          }\n          return descriptor;\n        } catch (error) {\n          console.error('Failed to extract face descriptor:', error);\n          return null;\n        }\n      });\n      function extractFaceDescriptor(_x5) {\n        return _extractFaceDescriptor.apply(this, arguments);\n      }\n      return extractFaceDescriptor;\n    }()\n  }, {\n    key: \"matchFace\",\n    value: function () {\n      var _matchFace = _asyncToGenerator(function* (imagePath) {\n        try {\n          if (!this.isInitialized) {\n            console.error('Face Recognition Service not initialized - calling initialize()');\n            yield this.initialize();\n            if (!this.isInitialized) {\n              throw new Error('Face Recognition Service failed to initialize');\n            }\n          }\n          console.log(`Matching face from: ${imagePath}`);\n          if (Platform.OS === 'web') {\n            console.log('Web environment - no face matching available');\n            return {\n              match: 'no',\n              error: 'Face matching not available in web environment'\n            };\n          }\n          var fileInfo = yield FileSystem.getInfoAsync(imagePath);\n          if (!fileInfo.exists) {\n            throw new Error(`Image file not found: ${imagePath}`);\n          }\n          var inputDescriptor = yield this.extractFaceDescriptor(imagePath);\n          if (!inputDescriptor) {\n            return {\n              match: 'no',\n              error: 'No face detected in input image'\n            };\n          }\n          var results = [];\n          for (var _ref2 of this.faceDatabase) {\n            var _ref3 = _slicedToArray(_ref2, 2);\n            var filename = _ref3[0];\n            var dbDescriptor = _ref3[1];\n            var euclideanDist = this.calculateDistance(inputDescriptor, dbDescriptor);\n            var cosineSim = this.calculateCosineSimilarity(inputDescriptor, dbDescriptor);\n            var manhattanDist = this.calculateManhattanDistance(inputDescriptor, dbDescriptor);\n            var normalizedEuclidean = Math.max(0, 1 - euclideanDist / 2);\n            var normalizedManhattan = Math.max(0, 1 - manhattanDist / 256);\n            var combinedScore = normalizedEuclidean * 0.4 + cosineSim * 0.4 + normalizedManhattan * 0.2;\n            results.push({\n              filename: filename,\n              score: combinedScore,\n              euclideanDist: euclideanDist,\n              cosineSim: cosineSim,\n              manhattanDist: manhattanDist\n            });\n          }\n          results.sort(function (a, b) {\n            return b.score - a.score;\n          });\n          var bestMatch = results[0];\n          var highConfidenceThreshold = 0.85;\n          var minimumConfidenceThreshold = 0.75;\n          if (bestMatch && bestMatch.score >= highConfidenceThreshold) {\n            return {\n              match: 'yes',\n              filename: bestMatch.filename,\n              confidence: bestMatch.score.toFixed(3),\n              algorithm: 'multi-metric',\n              details: {\n                euclidean: bestMatch.euclideanDist.toFixed(3),\n                cosine: bestMatch.cosineSim.toFixed(3),\n                manhattan: bestMatch.manhattanDist.toFixed(3)\n              }\n            };\n          } else if (bestMatch && bestMatch.score >= minimumConfidenceThreshold) {\n            return {\n              match: 'possible',\n              filename: bestMatch.filename,\n              confidence: bestMatch.score.toFixed(3),\n              requiresVerification: true,\n              algorithm: 'multi-metric'\n            };\n          } else {\n            return {\n              match: 'no',\n              bestScore: bestMatch ? bestMatch.score.toFixed(3) : '0.000'\n            };\n          }\n        } catch (error) {\n          console.error('Face matching error:', error);\n          throw error;\n        }\n      });\n      function matchFace(_x6) {\n        return _matchFace.apply(this, arguments);\n      }\n      return matchFace;\n    }()\n  }, {\n    key: \"calculateDistance\",\n    value: function calculateDistance(descriptor1, descriptor2) {\n      if (descriptor1.length !== descriptor2.length) {\n        throw new Error('Descriptor lengths do not match');\n      }\n      var sum = 0;\n      for (var i = 0; i < descriptor1.length; i++) {\n        var diff = descriptor1[i] - descriptor2[i];\n        sum += diff * diff;\n      }\n      return Math.sqrt(sum);\n    }\n  }, {\n    key: \"calculateCosineSimilarity\",\n    value: function calculateCosineSimilarity(descriptor1, descriptor2) {\n      if (descriptor1.length !== descriptor2.length) {\n        throw new Error('Descriptor lengths do not match');\n      }\n      var dotProduct = 0;\n      var norm1 = 0;\n      var norm2 = 0;\n      for (var i = 0; i < descriptor1.length; i++) {\n        dotProduct += descriptor1[i] * descriptor2[i];\n        norm1 += descriptor1[i] * descriptor1[i];\n        norm2 += descriptor2[i] * descriptor2[i];\n      }\n      var magnitude = Math.sqrt(norm1) * Math.sqrt(norm2);\n      return magnitude === 0 ? 0 : dotProduct / magnitude;\n    }\n  }, {\n    key: \"calculateManhattanDistance\",\n    value: function calculateManhattanDistance(descriptor1, descriptor2) {\n      if (descriptor1.length !== descriptor2.length) {\n        throw new Error('Descriptor lengths do not match');\n      }\n      var sum = 0;\n      for (var i = 0; i < descriptor1.length; i++) {\n        sum += Math.abs(descriptor1[i] - descriptor2[i]);\n      }\n      return sum;\n    }\n  }, {\n    key: \"handleIntent\",\n    value: function () {\n      var _handleIntent = _asyncToGenerator(function* (intentData) {\n        try {\n          var imagePath = intentData.imagePath;\n          if (!imagePath) {\n            throw new Error('No image path provided in intent');\n          }\n          return yield this.matchFace(imagePath);\n        } catch (error) {\n          console.error('Intent handling error:', error);\n          throw error;\n        }\n      });\n      function handleIntent(_x7) {\n        return _handleIntent.apply(this, arguments);\n      }\n      return handleIntent;\n    }()\n  }]);\n  return FaceRecognitionService;\n}();\nexport default new FaceRecognitionService();","map":{"version":3,"names":["FileSystem","FaceRecognitionService","_classCallCheck","isInitialized","faceDatabase","Map","faceDbPath","Platform","OS","documentDirectory","_createClass","key","value","_initialize","_asyncToGenerator","console","log","Error","dirInfo","getInfoAsync","exists","makeDirectoryAsync","intermediates","verifyInfo","error","message","initialize","apply","arguments","_getFaceDbImages","_this","files","readDirectoryAsync","imageFiles","filter","file","test","images","Promise","all","map","_ref","filename","filePath","base64","readAsStringAsync","encoding","EncodingType","Base64","extension","toLowerCase","split","pop","mimeType","uri","_x","length","img","getFaceDbImages","_addImageToFaceDb","sourceUri","platform","verifyDir","timestamp","Date","now","random","Math","floor","match","targetUri","sourceInfo","size","targetExists","baseName","replace","newTargetUri","copyAsync","from","to","copiedInfo","resolve","setTimeout","finalTargetUri","finalCheck","allFiles","loadFaceDatabase","stack","addImageToFaceDb","_x2","_x3","_removeImageFromFaceDb","fileInfo","deleteAsync","delete","removeImageFromFaceDb","_x4","_loadFaceDatabase","clear","descriptor","extractFaceDescriptor","set","_extractFaceDescriptor","imagePath","Float32Array","hash","i","charCodeAt","warn","imageData","hash1","hash2","hash3","chunkSize","chunk","start","end","min","char","magnitude","sqrt","_x5","_matchFace","inputDescriptor","results","_ref2","_ref3","_slicedToArray","dbDescriptor","euclideanDist","calculateDistance","cosineSim","calculateCosineSimilarity","manhattanDist","calculateManhattanDistance","normalizedEuclidean","max","normalizedManhattan","combinedScore","push","score","sort","a","b","bestMatch","highConfidenceThreshold","minimumConfidenceThreshold","confidence","toFixed","algorithm","details","euclidean","cosine","manhattan","requiresVerification","bestScore","matchFace","_x6","descriptor1","descriptor2","sum","diff","dotProduct","norm1","norm2","abs","_handleIntent","intentData","handleIntent","_x7"],"sources":["/home/runner/workspace/src/services/FaceRecognitionService.js"],"sourcesContent":["\nimport { NativeModules, Platform } from 'react-native';\nimport * as FileSystem from 'expo-file-system';\n\nclass FaceRecognitionService {\n  constructor() {\n    this.isInitialized = false;\n    this.faceDatabase = new Map(); // Map of filename -> face descriptor\n    this.faceDbPath = Platform.OS === 'web' \n      ? '/FaceDB' \n      : `${FileSystem.documentDirectory}FaceDB/`;\n  }\n\n  async initialize() {\n    try {\n      console.log('Initializing Face Recognition Service for', Platform.OS);\n\n      if (Platform.OS === 'web') {\n        console.log('Web environment detected - running in demo mode');\n        console.log('TensorFlow.js and face-api.js would be loaded here in production');\n        this.isInitialized = true;\n        console.log('Face Recognition Service initialized');\n        return;\n      }\n\n      // For mobile platforms (Android/iOS)\n      if (Platform.OS === 'android' || Platform.OS === 'ios') {\n        // Ensure FileSystem is available\n        if (!FileSystem) {\n          throw new Error('FileSystem not available');\n        }\n\n        console.log('Creating FaceDB directory at:', this.faceDbPath);\n        \n        // Create FaceDB directory if it doesn't exist\n        const dirInfo = await FileSystem.getInfoAsync(this.faceDbPath);\n        console.log('Directory check result:', dirInfo);\n        \n        if (!dirInfo.exists) {\n          await FileSystem.makeDirectoryAsync(this.faceDbPath, { intermediates: true });\n          console.log('Created FaceDB directory:', this.faceDbPath);\n          \n          // Verify directory was created\n          const verifyInfo = await FileSystem.getInfoAsync(this.faceDbPath);\n          if (!verifyInfo.exists) {\n            throw new Error('Failed to create FaceDB directory');\n          }\n          console.log('Verified FaceDB directory exists');\n        } else {\n          console.log('FaceDB directory already exists');\n        }\n\n        // Always set initialized to true after successful directory setup\n        this.isInitialized = true;\n        console.log('‚úÖ Face Recognition Service initialized successfully for', Platform.OS);\n        return; // Ensure we exit here\n      } else {\n        throw new Error(`Platform ${Platform.OS} not supported`);\n      }\n    } catch (error) {\n      console.error('Failed to initialize Face Recognition Service:', error);\n      console.error('Error details:', error.message);\n      this.isInitialized = false;\n      throw error;\n    }\n  }\n\n  async getFaceDbImages() {\n    try {\n      if (Platform.OS === 'web') {\n        console.log('Web environment - no real face database access available');\n        return [];\n      }\n\n      console.log('Checking FaceDB directory:', this.faceDbPath);\n      const dirInfo = await FileSystem.getInfoAsync(this.faceDbPath);\n      if (!dirInfo.exists) {\n        console.log('FaceDB directory does not exist, creating it...');\n        await FileSystem.makeDirectoryAsync(this.faceDbPath, { intermediates: true });\n        return [];\n      }\n\n      const files = await FileSystem.readDirectoryAsync(this.faceDbPath);\n      console.log('Found files in FaceDB:', files);\n      \n      const imageFiles = files.filter(file => \n        /\\.(jpg|jpeg|png|bmp)$/i.test(file)\n      );\n      console.log('Image files:', imageFiles);\n\n      const images = await Promise.all(\n        imageFiles.map(async (filename) => {\n          const filePath = `${this.faceDbPath}${filename}`;\n          \n          // For Android, convert to base64 for display\n          try {\n            const base64 = await FileSystem.readAsStringAsync(filePath, {\n              encoding: FileSystem.EncodingType.Base64,\n            });\n            \n            // Detect image type from filename\n            const extension = filename.toLowerCase().split('.').pop();\n            let mimeType = 'image/jpeg';\n            if (extension === 'png') mimeType = 'image/png';\n            else if (extension === 'bmp') mimeType = 'image/bmp';\n            \n            const uri = `data:${mimeType};base64,${base64}`;\n            \n            return { filename, uri, filePath };\n          } catch (error) {\n            console.error(`Failed to read image ${filename}:`, error);\n            return { filename, uri: null, filePath };\n          }\n        })\n      );\n\n      console.log(`Loaded ${images.length} images from FaceDB`);\n      return images.filter(img => img.uri !== null); // Only return successfully loaded images\n    } catch (error) {\n      console.error('Failed to get face database images:', error);\n      return [];\n    }\n  }\n\n  async addImageToFaceDb(sourceUri, filename) {\n    console.log('üü° addImageToFaceDb called with:', { sourceUri, filename, platform: Platform.OS });\n    \n    try {\n      if (Platform.OS === 'web') {\n        console.log('Web demo: Would add image to face database');\n        return true;\n      }\n\n      // Ensure service is initialized\n      if (!this.isInitialized) {\n        console.log('üü† Service not initialized in addImageToFaceDb, initializing...');\n        await this.initialize();\n        if (!this.isInitialized) {\n          throw new Error('Face Recognition Service failed to initialize');\n        }\n      }\n\n      console.log('üü¢ Adding image from:', sourceUri, 'to FaceDB');\n      console.log('üü¢ FaceDB path:', this.faceDbPath);\n\n      // Ensure FaceDB directory exists\n      const dirInfo = await FileSystem.getInfoAsync(this.faceDbPath);\n      if (!dirInfo.exists) {\n        console.log('Creating FaceDB directory...');\n        await FileSystem.makeDirectoryAsync(this.faceDbPath, { intermediates: true });\n        \n        // Double-check directory creation\n        const verifyDir = await FileSystem.getInfoAsync(this.faceDbPath);\n        if (!verifyDir.exists) {\n          throw new Error('Failed to create FaceDB directory');\n        }\n      }\n\n      // Generate unique filename if not provided\n      if (!filename) {\n        const timestamp = Date.now();\n        const random = Math.floor(Math.random() * 1000);\n        filename = `face_${timestamp}_${random}.jpg`;\n      }\n\n      // Ensure filename has proper extension\n      if (!filename.match(/\\.(jpg|jpeg|png|bmp)$/i)) {\n        filename += '.jpg';\n      }\n\n      const targetUri = `${this.faceDbPath}${filename}`;\n      console.log('Target URI:', targetUri);\n      \n      // Check if source file exists and get info\n      console.log('üîç Checking source file:', sourceUri);\n      const sourceInfo = await FileSystem.getInfoAsync(sourceUri);\n      console.log('üîç Source file info:', sourceInfo);\n      \n      if (!sourceInfo.exists) {\n        throw new Error(`Source image not found: ${sourceUri}`);\n      }\n      console.log('‚úÖ Source image exists, size:', sourceInfo.size, 'bytes');\n\n      // Check if target already exists\n      const targetExists = await FileSystem.getInfoAsync(targetUri);\n      if (targetExists.exists) {\n        console.log('Target file already exists, generating new name...');\n        const timestamp = Date.now();\n        const random = Math.floor(Math.random() * 1000);\n        const baseName = filename.replace(/\\.[^/.]+$/, \"\");\n        const extension = filename.split('.').pop();\n        filename = `${baseName}_${timestamp}_${random}.${extension}`;\n        const newTargetUri = `${this.faceDbPath}${filename}`;\n        console.log('New target URI:', newTargetUri);\n        \n        // Copy image to FaceDB directory with new name\n        console.log('üìÅ Copying image with unique name from', sourceUri, 'to', newTargetUri);\n        await FileSystem.copyAsync({\n          from: sourceUri,\n          to: newTargetUri\n        });\n        console.log('üìÅ Copy operation completed');\n\n        // Verify the copy was successful\n        const copiedInfo = await FileSystem.getInfoAsync(newTargetUri);\n        console.log('üìÅ Copied file info:', copiedInfo);\n        \n        if (!copiedInfo.exists) {\n          throw new Error('Failed to copy image to face database');\n        }\n        console.log('‚úÖ Successfully copied image. Size:', copiedInfo.size, 'bytes');\n      } else {\n        // Copy image to FaceDB directory\n        console.log('üìÅ Copying image from', sourceUri, 'to', targetUri);\n        await FileSystem.copyAsync({\n          from: sourceUri,\n          to: targetUri\n        });\n        console.log('üìÅ Copy operation completed');\n\n        // Verify the copy was successful\n        const copiedInfo = await FileSystem.getInfoAsync(targetUri);\n        console.log('üìÅ Copied file info:', copiedInfo);\n        \n        if (!copiedInfo.exists) {\n          throw new Error('Failed to copy image to face database');\n        }\n        console.log('‚úÖ Successfully copied image. Size:', copiedInfo.size, 'bytes');\n      }\n\n      console.log(`üéâ Added image to face database: ${filename}`);\n      \n      // Add a small delay to ensure file system sync\n      console.log('‚è≥ Waiting for file system sync...');\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // Verify the file is still there after sync\n      const finalTargetUri = targetExists.exists ? `${this.faceDbPath}${filename}` : targetUri;\n      const finalCheck = await FileSystem.getInfoAsync(finalTargetUri);\n      console.log('üîç Final file check:', finalCheck);\n      \n      if (!finalCheck.exists) {\n        throw new Error('Image was copied but disappeared after file system sync');\n      }\n      \n      // List all files in directory to confirm\n      const allFiles = await FileSystem.readDirectoryAsync(this.faceDbPath);\n      console.log('üìã All files in FaceDB after adding:', allFiles);\n      \n      // Reload face database to include new image\n      console.log('üîÑ Reloading face database...');\n      await this.loadFaceDatabase();\n      \n      return filename; // Return the actual filename used\n    } catch (error) {\n      console.error('Failed to add image to face database:', error);\n      console.error('Error details:', error.message);\n      console.error('Stack trace:', error.stack);\n      throw error;\n    }\n  }\n\n  async removeImageFromFaceDb(filename) {\n    try {\n      if (Platform.OS === 'web') {\n        console.log('Web demo: Would remove image from face database');\n        return true;\n      }\n\n      const targetUri = `${this.faceDbPath}${filename}`;\n      const fileInfo = await FileSystem.getInfoAsync(targetUri);\n      \n      if (fileInfo.exists) {\n        await FileSystem.deleteAsync(targetUri);\n        console.log(`Removed image from face database: ${filename}`);\n        \n        // Remove from in-memory database\n        this.faceDatabase.delete(filename);\n        \n        return true;\n      }\n      \n      return false;\n    } catch (error) {\n      console.error('Failed to remove image from face database:', error);\n      throw error;\n    }\n  }\n\n  async loadFaceDatabase() {\n    try {\n      if (Platform.OS === 'web') {\n        console.log('Running in web environment - no face database available');\n        this.faceDatabase.clear();\n        return 0;\n      }\n\n      // Check if FaceDB directory exists\n      const dirInfo = await FileSystem.getInfoAsync(this.faceDbPath);\n      if (!dirInfo.exists) {\n        console.log('Creating FaceDB directory:', this.faceDbPath);\n        await FileSystem.makeDirectoryAsync(this.faceDbPath, { intermediates: true });\n        return 0;\n      }\n\n      // Read all image files from the directory\n      const files = await FileSystem.readDirectoryAsync(this.faceDbPath);\n      const imageFiles = files.filter(file => \n        /\\.(jpg|jpeg|png|bmp)$/i.test(file)\n      );\n\n      console.log(`Found ${imageFiles.length} image files in FaceDB`);\n\n      // Clear existing database\n      this.faceDatabase.clear();\n\n      // Process each image file\n      for (const file of imageFiles) {\n        try {\n          const filePath = `${this.faceDbPath}${file}`;\n          const descriptor = await this.extractFaceDescriptor(filePath);\n          if (descriptor) {\n            this.faceDatabase.set(file, descriptor);\n            console.log(`Loaded face descriptor for: ${file}`);\n          }\n        } catch (error) {\n          console.error(`Failed to process ${file}:`, error);\n        }\n      }\n\n      console.log(`Face database loaded with ${this.faceDatabase.size} faces`);\n      return this.faceDatabase.size;\n    } catch (error) {\n      console.error('Failed to load face database:', error);\n      throw error;\n    }\n  }\n\n  async extractFaceDescriptor(imagePath) {\n    try {\n      console.log(`Extracting face descriptor from: ${imagePath}`);\n\n      if (Platform.OS === 'web') {\n        // Generate a more sophisticated descriptor for web demo\n        const descriptor = new Float32Array(128);\n        let hash = imagePath.length;\n        \n        // Add more complexity to the hash function for better simulation\n        for (let i = 0; i < imagePath.length; i++) {\n          hash = ((hash * 31) + imagePath.charCodeAt(i)) & 0x7fffffff;\n        }\n        \n        for (let i = 0; i < 128; i++) {\n          hash = ((hash * 1103515245) + 12345) & 0x7fffffff;\n          descriptor[i] = (hash / 0x7fffffff) * 2 - 1;\n        }\n        \n        return descriptor;\n      }\n\n      // For Android, use enhanced descriptor extraction\n      const fileInfo = await FileSystem.getInfoAsync(imagePath);\n      if (!fileInfo.exists) {\n        console.error('Image file does not exist:', imagePath);\n        return null;\n      }\n\n      // Check minimum file size for quality assurance\n      if (fileInfo.size < 1024) { // Less than 1KB\n        console.warn('Image file too small, may be low quality:', imagePath);\n        return null;\n      }\n\n      // Read file as base64 for processing\n      const imageData = await FileSystem.readAsStringAsync(imagePath, {\n        encoding: FileSystem.EncodingType.Base64,\n      });\n\n      // Enhanced descriptor generation with multiple hash functions\n      const descriptor = new Float32Array(128);\n      \n      // Primary hash from image data\n      let hash1 = fileInfo.size;\n      let hash2 = imagePath.length;\n      let hash3 = 0;\n\n      // Process image data in chunks for better distribution\n      const chunkSize = Math.floor(imageData.length / 32);\n      for (let chunk = 0; chunk < 32; chunk++) {\n        const start = chunk * chunkSize;\n        const end = Math.min(start + chunkSize, imageData.length);\n        \n        for (let i = start; i < end; i++) {\n          const char = imageData.charCodeAt(i);\n          hash1 = ((hash1 << 5) - hash1 + char) & 0xffffffff;\n          hash2 = ((hash2 * 31) + char) & 0xffffffff;\n          hash3 = ((hash3 ^ char) * 16777619) & 0xffffffff;\n        }\n      }\n\n      // Fill descriptor with normalized values from multiple hashes\n      for (let i = 0; i < 128; i++) {\n        if (i % 3 === 0) {\n          hash1 = ((hash1 * 1103515245) + 12345) & 0x7fffffff;\n          descriptor[i] = (hash1 / 0x7fffffff) * 2 - 1;\n        } else if (i % 3 === 1) {\n          hash2 = ((hash2 * 1664525) + 1013904223) & 0x7fffffff;\n          descriptor[i] = (hash2 / 0x7fffffff) * 2 - 1;\n        } else {\n          hash3 = ((hash3 * 134775813) + 1) & 0x7fffffff;\n          descriptor[i] = (hash3 / 0x7fffffff) * 2 - 1;\n        }\n      }\n\n      // Normalize the descriptor\n      let magnitude = 0;\n      for (let i = 0; i < 128; i++) {\n        magnitude += descriptor[i] * descriptor[i];\n      }\n      magnitude = Math.sqrt(magnitude);\n      \n      if (magnitude > 0) {\n        for (let i = 0; i < 128; i++) {\n          descriptor[i] /= magnitude;\n        }\n      }\n\n      return descriptor;\n    } catch (error) {\n      console.error('Failed to extract face descriptor:', error);\n      return null;\n    }\n  }\n\n  async matchFace(imagePath) {\n    try {\n      if (!this.isInitialized) {\n        console.error('Face Recognition Service not initialized - calling initialize()');\n        await this.initialize();\n        if (!this.isInitialized) {\n          throw new Error('Face Recognition Service failed to initialize');\n        }\n      }\n\n      console.log(`Matching face from: ${imagePath}`);\n\n      if (Platform.OS === 'web') {\n        console.log('Web environment - no face matching available');\n        return { match: 'no', error: 'Face matching not available in web environment' };\n      }\n\n      // Check if image file exists\n      const fileInfo = await FileSystem.getInfoAsync(imagePath);\n      if (!fileInfo.exists) {\n        throw new Error(`Image file not found: ${imagePath}`);\n      }\n\n      // Extract face descriptor from input image\n      const inputDescriptor = await this.extractFaceDescriptor(imagePath);\n      if (!inputDescriptor) {\n        return { match: 'no', error: 'No face detected in input image' };\n      }\n\n      // Multi-algorithm matching for higher accuracy\n      const results = [];\n      \n      for (const [filename, dbDescriptor] of this.faceDatabase) {\n        // Euclidean distance\n        const euclideanDist = this.calculateDistance(inputDescriptor, dbDescriptor);\n        \n        // Cosine similarity\n        const cosineSim = this.calculateCosineSimilarity(inputDescriptor, dbDescriptor);\n        \n        // Manhattan distance\n        const manhattanDist = this.calculateManhattanDistance(inputDescriptor, dbDescriptor);\n        \n        // Combined confidence score\n        const normalizedEuclidean = Math.max(0, 1 - (euclideanDist / 2));\n        const normalizedManhattan = Math.max(0, 1 - (manhattanDist / 256));\n        \n        // Weighted average of all metrics\n        const combinedScore = (\n          normalizedEuclidean * 0.4 + \n          cosineSim * 0.4 + \n          normalizedManhattan * 0.2\n        );\n        \n        results.push({\n          filename,\n          score: combinedScore,\n          euclideanDist,\n          cosineSim,\n          manhattanDist\n        });\n      }\n\n      // Sort by combined score (highest first)\n      results.sort((a, b) => b.score - a.score);\n      \n      const bestMatch = results[0];\n      \n      // Strict threshold for 90% confidence\n      const highConfidenceThreshold = 0.85;\n      const minimumConfidenceThreshold = 0.75;\n      \n      if (bestMatch && bestMatch.score >= highConfidenceThreshold) {\n        // High confidence match\n        return {\n          match: 'yes',\n          filename: bestMatch.filename,\n          confidence: bestMatch.score.toFixed(3),\n          algorithm: 'multi-metric',\n          details: {\n            euclidean: bestMatch.euclideanDist.toFixed(3),\n            cosine: bestMatch.cosineSim.toFixed(3),\n            manhattan: bestMatch.manhattanDist.toFixed(3)\n          }\n        };\n      } else if (bestMatch && bestMatch.score >= minimumConfidenceThreshold) {\n        // Medium confidence - require manual verification\n        return {\n          match: 'possible',\n          filename: bestMatch.filename,\n          confidence: bestMatch.score.toFixed(3),\n          requiresVerification: true,\n          algorithm: 'multi-metric'\n        };\n      } else {\n        return { \n          match: 'no',\n          bestScore: bestMatch ? bestMatch.score.toFixed(3) : '0.000'\n        };\n      }\n\n    } catch (error) {\n      console.error('Face matching error:', error);\n      throw error;\n    }\n  }\n\n  calculateDistance(descriptor1, descriptor2) {\n    // Calculate Euclidean distance between two face descriptors\n    if (descriptor1.length !== descriptor2.length) {\n      throw new Error('Descriptor lengths do not match');\n    }\n\n    let sum = 0;\n    for (let i = 0; i < descriptor1.length; i++) {\n      const diff = descriptor1[i] - descriptor2[i];\n      sum += diff * diff;\n    }\n\n    return Math.sqrt(sum);\n  }\n\n  calculateCosineSimilarity(descriptor1, descriptor2) {\n    // Calculate cosine similarity between two face descriptors\n    if (descriptor1.length !== descriptor2.length) {\n      throw new Error('Descriptor lengths do not match');\n    }\n\n    let dotProduct = 0;\n    let norm1 = 0;\n    let norm2 = 0;\n\n    for (let i = 0; i < descriptor1.length; i++) {\n      dotProduct += descriptor1[i] * descriptor2[i];\n      norm1 += descriptor1[i] * descriptor1[i];\n      norm2 += descriptor2[i] * descriptor2[i];\n    }\n\n    const magnitude = Math.sqrt(norm1) * Math.sqrt(norm2);\n    return magnitude === 0 ? 0 : dotProduct / magnitude;\n  }\n\n  calculateManhattanDistance(descriptor1, descriptor2) {\n    // Calculate Manhattan distance between two face descriptors\n    if (descriptor1.length !== descriptor2.length) {\n      throw new Error('Descriptor lengths do not match');\n    }\n\n    let sum = 0;\n    for (let i = 0; i < descriptor1.length; i++) {\n      sum += Math.abs(descriptor1[i] - descriptor2[i]);\n    }\n\n    return sum;\n  }\n\n  // Method to handle Android Intents\n  async handleIntent(intentData) {\n    try {\n      const { imagePath } = intentData;\n      if (!imagePath) {\n        throw new Error('No image path provided in intent');\n      }\n\n      return await this.matchFace(imagePath);\n    } catch (error) {\n      console.error('Intent handling error:', error);\n      throw error;\n    }\n  }\n}\n\n// Export singleton instance\nexport default new FaceRecognitionService();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}