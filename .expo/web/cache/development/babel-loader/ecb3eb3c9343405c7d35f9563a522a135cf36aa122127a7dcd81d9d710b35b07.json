{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport * as tf from '@tensorflow/tfjs';\nimport '@tensorflow/tfjs-react-native';\nimport * as faceapi from 'face-api.js';\nimport RNFS from 'react-native-fs';\nvar FaceRecognitionService = function () {\n  function FaceRecognitionService() {\n    _classCallCheck(this, FaceRecognitionService);\n    this.isInitialized = false;\n    this.faceDatabase = new Map();\n    this.faceDbPath = `${RNFS.ExternalStorageDirectoryPath}/FaceDB`;\n    this.modelsLoaded = false;\n  }\n  _createClass(FaceRecognitionService, [{\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator(function* () {\n        if (this.isInitialized) return;\n        try {\n          yield tf.ready();\n          console.log('TensorFlow.js initialized');\n          yield this.loadModels();\n          this.isInitialized = true;\n          console.log('Face Recognition Service initialized');\n        } catch (error) {\n          console.error('Failed to initialize Face Recognition Service:', error);\n          throw error;\n        }\n      });\n      function initialize() {\n        return _initialize.apply(this, arguments);\n      }\n      return initialize;\n    }()\n  }, {\n    key: \"loadModels\",\n    value: function () {\n      var _loadModels = _asyncToGenerator(function* () {\n        try {\n          console.log('Loading face detection models...');\n          this.modelsLoaded = true;\n          console.log('Models loaded successfully');\n        } catch (error) {\n          console.error('Failed to load models:', error);\n          throw error;\n        }\n      });\n      function loadModels() {\n        return _loadModels.apply(this, arguments);\n      }\n      return loadModels;\n    }()\n  }, {\n    key: \"loadFaceDatabase\",\n    value: function () {\n      var _loadFaceDatabase = _asyncToGenerator(function* () {\n        try {\n          var exists = yield RNFS.exists(this.faceDbPath);\n          if (!exists) {\n            console.log('Creating FaceDB directory:', this.faceDbPath);\n            yield RNFS.mkdir(this.faceDbPath);\n            return 0;\n          }\n          var files = yield RNFS.readDir(this.faceDbPath);\n          var imageFiles = files.filter(function (file) {\n            return file.isFile() && /\\.(jpg|jpeg|png|bmp)$/i.test(file.name);\n          });\n          console.log(`Found ${imageFiles.length} image files in FaceDB`);\n          this.faceDatabase.clear();\n          for (var file of imageFiles) {\n            try {\n              var descriptor = yield this.extractFaceDescriptor(file.path);\n              if (descriptor) {\n                this.faceDatabase.set(file.name, descriptor);\n                console.log(`Loaded face descriptor for: ${file.name}`);\n              }\n            } catch (error) {\n              console.error(`Failed to process ${file.name}:`, error);\n            }\n          }\n          console.log(`Face database loaded with ${this.faceDatabase.size} faces`);\n          return this.faceDatabase.size;\n        } catch (error) {\n          console.error('Failed to load face database:', error);\n          throw error;\n        }\n      });\n      function loadFaceDatabase() {\n        return _loadFaceDatabase.apply(this, arguments);\n      }\n      return loadFaceDatabase;\n    }()\n  }, {\n    key: \"extractFaceDescriptor\",\n    value: function () {\n      var _extractFaceDescriptor = _asyncToGenerator(function* (imagePath) {\n        try {\n          console.log(`Extracting face descriptor from: ${imagePath}`);\n          var mockDescriptor = new Float32Array(128);\n          for (var i = 0; i < 128; i++) {\n            mockDescriptor[i] = Math.random();\n          }\n          return mockDescriptor;\n        } catch (error) {\n          console.error('Failed to extract face descriptor:', error);\n          return null;\n        }\n      });\n      function extractFaceDescriptor(_x) {\n        return _extractFaceDescriptor.apply(this, arguments);\n      }\n      return extractFaceDescriptor;\n    }()\n  }, {\n    key: \"matchFace\",\n    value: function () {\n      var _matchFace = _asyncToGenerator(function* (imagePath) {\n        try {\n          if (!this.isInitialized) {\n            throw new Error('Face Recognition Service not initialized');\n          }\n          console.log(`Matching face from: ${imagePath}`);\n          var exists = yield RNFS.exists(imagePath);\n          if (!exists) {\n            throw new Error(`Image file not found: ${imagePath}`);\n          }\n          var inputDescriptor = yield this.extractFaceDescriptor(imagePath);\n          if (!inputDescriptor) {\n            return {\n              match: 'no',\n              error: 'No face detected in input image'\n            };\n          }\n          var bestMatch = null;\n          var bestDistance = Infinity;\n          var threshold = 0.6;\n          for (var _ref of this.faceDatabase) {\n            var _ref2 = _slicedToArray(_ref, 2);\n            var filename = _ref2[0];\n            var dbDescriptor = _ref2[1];\n            var distance = this.calculateDistance(inputDescriptor, dbDescriptor);\n            if (distance < bestDistance) {\n              bestDistance = distance;\n              bestMatch = filename;\n            }\n          }\n          if (bestMatch && bestDistance < threshold) {\n            return {\n              match: 'yes',\n              filename: bestMatch,\n              confidence: (1 - bestDistance).toFixed(3)\n            };\n          } else {\n            return {\n              match: 'no'\n            };\n          }\n        } catch (error) {\n          console.error('Face matching error:', error);\n          throw error;\n        }\n      });\n      function matchFace(_x2) {\n        return _matchFace.apply(this, arguments);\n      }\n      return matchFace;\n    }()\n  }, {\n    key: \"calculateDistance\",\n    value: function calculateDistance(descriptor1, descriptor2) {\n      if (descriptor1.length !== descriptor2.length) {\n        throw new Error('Descriptor lengths do not match');\n      }\n      var sum = 0;\n      for (var i = 0; i < descriptor1.length; i++) {\n        var diff = descriptor1[i] - descriptor2[i];\n        sum += diff * diff;\n      }\n      return Math.sqrt(sum);\n    }\n  }, {\n    key: \"handleIntent\",\n    value: function () {\n      var _handleIntent = _asyncToGenerator(function* (intentData) {\n        try {\n          var imagePath = intentData.imagePath;\n          if (!imagePath) {\n            throw new Error('No image path provided in intent');\n          }\n          return yield this.matchFace(imagePath);\n        } catch (error) {\n          console.error('Intent handling error:', error);\n          throw error;\n        }\n      });\n      function handleIntent(_x3) {\n        return _handleIntent.apply(this, arguments);\n      }\n      return handleIntent;\n    }()\n  }]);\n  return FaceRecognitionService;\n}();\nexport default new FaceRecognitionService();","map":{"version":3,"names":["tf","faceapi","RNFS","FaceRecognitionService","_classCallCheck","isInitialized","faceDatabase","Map","faceDbPath","ExternalStorageDirectoryPath","modelsLoaded","_createClass","key","value","_initialize","_asyncToGenerator","ready","console","log","loadModels","error","initialize","apply","arguments","_loadModels","_loadFaceDatabase","exists","mkdir","files","readDir","imageFiles","filter","file","isFile","test","name","length","clear","descriptor","extractFaceDescriptor","path","set","size","loadFaceDatabase","_extractFaceDescriptor","imagePath","mockDescriptor","Float32Array","i","Math","random","_x","_matchFace","Error","inputDescriptor","match","bestMatch","bestDistance","Infinity","threshold","_ref","_ref2","_slicedToArray","filename","dbDescriptor","distance","calculateDistance","confidence","toFixed","matchFace","_x2","descriptor1","descriptor2","sum","diff","sqrt","_handleIntent","intentData","handleIntent","_x3"],"sources":["/home/runner/workspace/src/services/FaceRecognitionService.js"],"sourcesContent":["\nimport * as tf from '@tensorflow/tfjs';\nimport '@tensorflow/tfjs-react-native';\nimport * as faceapi from 'face-api.js';\nimport RNFS from 'react-native-fs';\n\nclass FaceRecognitionService {\n  constructor() {\n    this.isInitialized = false;\n    this.faceDatabase = new Map(); // Map of filename -> face descriptor\n    this.faceDbPath = `${RNFS.ExternalStorageDirectoryPath}/FaceDB`;\n    this.modelsLoaded = false;\n  }\n\n  async initialize() {\n    if (this.isInitialized) return;\n\n    try {\n      // Initialize TensorFlow\n      await tf.ready();\n      console.log('TensorFlow.js initialized');\n\n      // Load face-api.js models (you'll need to include model files)\n      await this.loadModels();\n      \n      this.isInitialized = true;\n      console.log('Face Recognition Service initialized');\n    } catch (error) {\n      console.error('Failed to initialize Face Recognition Service:', error);\n      throw error;\n    }\n  }\n\n  async loadModels() {\n    try {\n      // Note: You'll need to include these model files in your assets\n      // For now, we'll use a simplified approach\n      console.log('Loading face detection models...');\n      \n      // In a real implementation, you would load the actual models:\n      // await faceapi.nets.tinyFaceDetector.loadFromUri('/assets/models');\n      // await faceapi.nets.faceLandmark68Net.loadFromUri('/assets/models');\n      // await faceapi.nets.faceRecognitionNet.loadFromUri('/assets/models');\n      \n      this.modelsLoaded = true;\n      console.log('Models loaded successfully');\n    } catch (error) {\n      console.error('Failed to load models:', error);\n      throw error;\n    }\n  }\n\n  async loadFaceDatabase() {\n    try {\n      // Check if FaceDB directory exists\n      const exists = await RNFS.exists(this.faceDbPath);\n      if (!exists) {\n        console.log('Creating FaceDB directory:', this.faceDbPath);\n        await RNFS.mkdir(this.faceDbPath);\n        return 0;\n      }\n\n      // Read all image files from the directory\n      const files = await RNFS.readDir(this.faceDbPath);\n      const imageFiles = files.filter(file => \n        file.isFile() && /\\.(jpg|jpeg|png|bmp)$/i.test(file.name)\n      );\n\n      console.log(`Found ${imageFiles.length} image files in FaceDB`);\n\n      // Clear existing database\n      this.faceDatabase.clear();\n\n      // Process each image file\n      for (const file of imageFiles) {\n        try {\n          const descriptor = await this.extractFaceDescriptor(file.path);\n          if (descriptor) {\n            this.faceDatabase.set(file.name, descriptor);\n            console.log(`Loaded face descriptor for: ${file.name}`);\n          }\n        } catch (error) {\n          console.error(`Failed to process ${file.name}:`, error);\n        }\n      }\n\n      console.log(`Face database loaded with ${this.faceDatabase.size} faces`);\n      return this.faceDatabase.size;\n    } catch (error) {\n      console.error('Failed to load face database:', error);\n      throw error;\n    }\n  }\n\n  async extractFaceDescriptor(imagePath) {\n    try {\n      // In a real implementation, you would:\n      // 1. Load the image\n      // 2. Detect faces using face-api.js\n      // 3. Extract face descriptors\n      \n      // For now, we'll simulate this with a simple approach\n      console.log(`Extracting face descriptor from: ${imagePath}`);\n      \n      // Simulate face descriptor (in real implementation, this would be the actual descriptor)\n      const mockDescriptor = new Float32Array(128); // Face descriptors are typically 128-dimensional\n      for (let i = 0; i < 128; i++) {\n        mockDescriptor[i] = Math.random(); // Random values for simulation\n      }\n      \n      return mockDescriptor;\n    } catch (error) {\n      console.error('Failed to extract face descriptor:', error);\n      return null;\n    }\n  }\n\n  async matchFace(imagePath) {\n    try {\n      if (!this.isInitialized) {\n        throw new Error('Face Recognition Service not initialized');\n      }\n\n      console.log(`Matching face from: ${imagePath}`);\n\n      // Check if image file exists\n      const exists = await RNFS.exists(imagePath);\n      if (!exists) {\n        throw new Error(`Image file not found: ${imagePath}`);\n      }\n\n      // Extract face descriptor from input image\n      const inputDescriptor = await this.extractFaceDescriptor(imagePath);\n      if (!inputDescriptor) {\n        return { match: 'no', error: 'No face detected in input image' };\n      }\n\n      // Compare with all faces in database\n      let bestMatch = null;\n      let bestDistance = Infinity;\n      const threshold = 0.6; // Similarity threshold\n\n      for (const [filename, dbDescriptor] of this.faceDatabase) {\n        const distance = this.calculateDistance(inputDescriptor, dbDescriptor);\n        \n        if (distance < bestDistance) {\n          bestDistance = distance;\n          bestMatch = filename;\n        }\n      }\n\n      // Check if best match is within threshold\n      if (bestMatch && bestDistance < threshold) {\n        return {\n          match: 'yes',\n          filename: bestMatch,\n          confidence: (1 - bestDistance).toFixed(3)\n        };\n      } else {\n        return { match: 'no' };\n      }\n\n    } catch (error) {\n      console.error('Face matching error:', error);\n      throw error;\n    }\n  }\n\n  calculateDistance(descriptor1, descriptor2) {\n    // Calculate Euclidean distance between two face descriptors\n    if (descriptor1.length !== descriptor2.length) {\n      throw new Error('Descriptor lengths do not match');\n    }\n\n    let sum = 0;\n    for (let i = 0; i < descriptor1.length; i++) {\n      const diff = descriptor1[i] - descriptor2[i];\n      sum += diff * diff;\n    }\n\n    return Math.sqrt(sum);\n  }\n\n  // Method to handle Android Intents (would be implemented with native modules)\n  async handleIntent(intentData) {\n    try {\n      const { imagePath } = intentData;\n      if (!imagePath) {\n        throw new Error('No image path provided in intent');\n      }\n\n      return await this.matchFace(imagePath);\n    } catch (error) {\n      console.error('Intent handling error:', error);\n      throw error;\n    }\n  }\n}\n\n// Export singleton instance\nexport default new FaceRecognitionService();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}